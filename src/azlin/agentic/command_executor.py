"""Command executor for agentic azlin commands.

This module executes azlin commands generated by the intent parser.
"""

import subprocess
from typing import Any


class CommandExecutionError(Exception):
    """Error executing azlin command."""


class CommandExecutor:
    """Executes azlin commands and tracks results."""

    def __init__(self, dry_run: bool = False):
        """Initialize command executor.

        Args:
            dry_run: If True, print commands without executing
        """
        self.dry_run = dry_run
        self.execution_history: list[dict[str, Any]] = []

    def execute(self, command_spec: dict[str, str]) -> dict[str, Any]:
        """Execute a single azlin command.

        Args:
            command_spec: Dict with 'command' and 'args' keys

        Returns:
            Execution result with stdout, stderr, returncode

        Example:
            >>> executor = CommandExecutor()
            >>> result = executor.execute({
            ...     "command": "azlin list",
            ...     "args": []
            ... })
            >>> print(result["success"])
            True
        """
        command = command_spec["command"]
        args = command_spec.get("args", [])

        # Build full command - ensure args is always a list
        args_list = args if isinstance(args, list) else [args]
        cmd_parts = command.split() + args_list

        if self.dry_run:
            result = {
                "command": " ".join(cmd_parts),
                "stdout": "[DRY RUN] Would execute command",
                "stderr": "",
                "returncode": 0,
                "success": True,
            }
        else:
            try:
                process = subprocess.run(
                    cmd_parts,
                    capture_output=True,
                    text=True,
                    timeout=300,  # 5 minute timeout
                )

                result = {
                    "command": " ".join(cmd_parts),
                    "stdout": process.stdout,
                    "stderr": process.stderr,
                    "returncode": process.returncode,
                    "success": process.returncode == 0,
                }

            except subprocess.TimeoutExpired as e:
                result = {
                    "command": " ".join(cmd_parts),
                    "stdout": "",
                    "stderr": "Command timed out after 300 seconds",
                    "returncode": -1,
                    "success": False,
                    "error": str(e),
                }

            except (FileNotFoundError, PermissionError) as e:
                result = {
                    "command": " ".join(cmd_parts),
                    "stdout": "",
                    "stderr": f"Failed to execute: {e}",
                    "returncode": -1,
                    "success": False,
                    "error": str(e),
                }

        # Track execution
        self.execution_history.append(result)

        return result

    def execute_plan(self, commands: list[dict[str, str]]) -> list[dict[str, Any]]:
        """Execute multiple commands in sequence.

        Args:
            commands: List of command specs

        Returns:
            List of execution results

        Note:
            Stops on first failure unless continue_on_error is set
        """
        results = []

        for cmd_spec in commands:
            result = self.execute(cmd_spec)
            results.append(result)

            # Stop on failure (can be made configurable)
            if not result["success"]:
                break

        return results

    def get_history(self) -> list[dict[str, Any]]:
        """Get execution history.

        Returns:
            List of all executed commands and results
        """
        return self.execution_history.copy()

    def clear_history(self) -> None:
        """Clear execution history."""
        self.execution_history.clear()


class ResultValidator:
    """Validates command execution results against original intent."""

    def __init__(self, api_key: str | None = None):
        """Initialize result validator.

        Args:
            api_key: Anthropic API key for Claude validation
        """
        import os

        import anthropic  # type: ignore[import-untyped]

        self.api_key = api_key or os.getenv("ANTHROPIC_API_KEY")
        if self.api_key:
            self.client = anthropic.Anthropic(api_key=self.api_key)
        else:
            self.client = None

    def validate(
        self,
        intent: dict[str, Any],
        execution_results: list[dict[str, Any]],
    ) -> dict[str, Any]:
        """Validate execution results against intent.

        Args:
            intent: Original user intent
            execution_results: Results from command execution

        Returns:
            Validation result with success status and message
        """
        # Simple validation without AI
        all_succeeded = all(r["success"] for r in execution_results)

        if not self.client:
            # Basic validation without Claude
            return {
                "success": all_succeeded,
                "message": "All commands executed successfully"
                if all_succeeded
                else "Some commands failed",
                "details": execution_results,
            }

        # AI-powered validation with Claude
        try:
            system_prompt = """You are validating whether azlin command execution met the user's intent.

Review the original intent and execution results.

Output JSON only:
{
    "success": true/false,
    "message": "Natural language summary for user",
    "issues": ["List of any problems or suggestions"]
}"""

            user_message = {
                "intent": intent,
                "execution_results": execution_results,
            }

            import json

            message = self.client.messages.create(
                model="claude-3-5-sonnet-20241022",
                max_tokens=1024,
                system=system_prompt,
                messages=[{"role": "user", "content": json.dumps(user_message)}],
            )

            response_text = message.content[0].text
            # Extract JSON
            start = response_text.find("{")
            end = response_text.rfind("}") + 1
            if start >= 0 and end > start:
                validation = json.loads(response_text[start:end])
                validation["details"] = execution_results
                return validation

        except Exception:  # noqa: S110
            # Fallback to simple validation on any error - intentionally silent
            pass

        # Return fallback validation if AI validation failed or errored
        return {
            "success": all_succeeded,
            "message": "Commands executed" if all_succeeded else "Some commands failed",
            "details": execution_results,
        }
