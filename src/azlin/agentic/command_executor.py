"""Command executor for agentic azlin commands.

This module executes azlin commands generated by the intent parser.
"""

import json
import logging
import subprocess
from typing import Any, cast

from azlin.agentic.types import ExecutionHistoryEvent

logger = logging.getLogger(__name__)


class CommandExecutionError(Exception):
    """Error executing azlin command."""


class CommandExecutor:
    """Executes azlin commands and tracks results."""

    def __init__(self, dry_run: bool = False):
        """Initialize command executor.

        Args:
            dry_run: If True, print commands without executing
        """
        self.dry_run = dry_run
        self.execution_history: list[ExecutionHistoryEvent] = []

    def execute(self, command_spec: dict[str, str]) -> ExecutionHistoryEvent:
        """Execute a single azlin command.

        Args:
            command_spec: Dict with 'command' and 'args' keys

        Returns:
            Execution result with stdout, stderr, returncode

        Example:
            >>> executor = CommandExecutor()
            >>> result = executor.execute({
            ...     "command": "azlin list",
            ...     "args": []
            ... })
            >>> print(result["success"])
            True
        """
        command = command_spec["command"]
        args = command_spec.get("args", [])

        # Build full command - ensure args is always a list
        args_list = args if isinstance(args, list) else [args]
        cmd_parts = command.split() + args_list

        result: ExecutionHistoryEvent

        if self.dry_run:
            result = cast(
                ExecutionHistoryEvent,
                {
                    "command": " ".join(cmd_parts),
                    "stdout": "[DRY RUN] Would execute command",
                    "stderr": "",
                    "returncode": 0,
                    "success": True,
                },
            )
        else:
            try:
                process = subprocess.run(
                    cmd_parts,
                    capture_output=True,
                    text=True,
                    timeout=300,  # 5 minute timeout
                )

                result = cast(
                    ExecutionHistoryEvent,
                    {
                        "command": " ".join(cmd_parts),
                        "stdout": process.stdout,
                        "stderr": process.stderr,
                        "returncode": process.returncode,
                        "success": process.returncode == 0,
                    },
                )

            except subprocess.TimeoutExpired as e:
                result = cast(
                    ExecutionHistoryEvent,
                    {
                        "command": " ".join(cmd_parts),
                        "stdout": "",
                        "stderr": "Command timed out after 300 seconds",
                        "returncode": -1,
                        "success": False,
                        "error": str(e),
                    },
                )

            except (FileNotFoundError, PermissionError) as e:
                result = cast(
                    ExecutionHistoryEvent,
                    {
                        "command": " ".join(cmd_parts),
                        "stdout": "",
                        "stderr": f"Failed to execute: {e}",
                        "returncode": -1,
                        "success": False,
                        "error": str(e),
                    },
                )

        # Track execution
        self.execution_history.append(result)

        return result

    def execute_plan(self, commands: list[dict[str, str]]) -> list[ExecutionHistoryEvent]:
        """Execute multiple commands in sequence.

        Args:
            commands: List of command specs

        Returns:
            List of execution results

        Note:
            Stops on first failure unless continue_on_error is set
        """
        results = []

        for cmd_spec in commands:
            result = self.execute(cmd_spec)
            results.append(result)

            # Stop on failure (can be made configurable)
            if not result["success"]:
                break

        return results

    def get_history(self) -> list[ExecutionHistoryEvent]:
        """Get execution history.

        Returns:
            List of all executed commands and results
        """
        return self.execution_history.copy()

    def clear_history(self) -> None:
        """Clear execution history."""
        self.execution_history.clear()


class ResultValidator:
    """Validates command execution results against original intent."""

    def __init__(self, api_key: str | None = None):
        """Initialize result validator.

        Args:
            api_key: Anthropic API key for Claude validation
        """
        import os

        import anthropic  # type: ignore[import-untyped]

        self.api_key = api_key or os.getenv("ANTHROPIC_API_KEY")
        if self.api_key:
            self.client = anthropic.Anthropic(api_key=self.api_key)
        else:
            self.client = None

    def validate(
        self,
        intent: dict[str, Any],
        execution_results: list[ExecutionHistoryEvent],
    ) -> dict[str, Any]:
        """Validate execution results against intent.

        Args:
            intent: Original user intent
            execution_results: Results from command execution

        Returns:
            Validation result with success status and message
        """
        # Simple validation without AI
        all_succeeded = all(r["success"] for r in execution_results)

        if not self.client:
            # Basic validation without Claude
            return {
                "success": all_succeeded,
                "message": "All commands executed successfully"
                if all_succeeded
                else "Some commands failed",
                "details": execution_results,
            }

        # AI-powered validation with Claude
        try:
            system_prompt = """You are validating whether azlin command execution met the user's intent.

Review the original intent and execution results.

Output JSON only:
{
    "success": true/false,
    "message": "Natural language summary for user",
    "issues": ["List of any problems or suggestions"]
}"""

            user_message = {
                "intent": intent,
                "execution_results": execution_results,
            }

            message = self.client.messages.create(
                model="claude-sonnet-4-5-20250929",
                max_tokens=1024,
                system=system_prompt,
                messages=[{"role": "user", "content": json.dumps(user_message)}],
            )

            response_text = message.content[0].text  # type: ignore[attr-defined]  # TextBlock always has .text
            # Extract JSON
            start = response_text.find("{")
            end = response_text.rfind("}") + 1
            if start >= 0 and end > start:
                validation = json.loads(response_text[start:end])
                validation["details"] = execution_results
                return validation

        except (json.JSONDecodeError, KeyError, IndexError) as e:
            # Fallback to simple validation on parsing errors
            logger.debug(
                "AI validation failed, falling back to simple validation: %s",
                str(e),
                exc_info=True,
            )
        except Exception as e:
            # Catch unexpected errors to prevent validation failures
            logger.warning(
                "Unexpected error during AI validation, falling back to simple validation: %s",
                str(e),
                exc_info=True,
            )

        # Return fallback validation if AI validation failed or errored
        return {
            "success": all_succeeded,
            "message": "Commands executed" if all_succeeded else "Some commands failed",
            "details": execution_results,
        }
