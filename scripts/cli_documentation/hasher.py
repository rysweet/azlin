"""CLI command change detection via hashing.

This module provides change detection for CLI commands by computing content
hashes. It helps determine when documentation needs to be regenerated by
detecting changes in command signatures, options, and help text.

Philosophy:
- Simple SHA-256 hashing
- JSON-based hash persistence
- Self-contained and regeneratable
"""

import hashlib
import json
from pathlib import Path
from typing import Dict, Optional

from .models import ChangeSet, CLIMetadata


class CLIHasher:
    """Detects changes in CLI commands via content hashing.

    This class computes SHA-256 hashes of command metadata to detect when
    commands have changed and documentation needs regeneration.
    """

    def __init__(self, hash_file: str = ".cli_doc_hashes.json"):
        """Initialize hasher with hash persistence file.

        Args:
            hash_file: Path to JSON file for storing hashes
        """
        self.hash_file = Path(hash_file)
        self._hashes: Dict[str, str] = {}
        self._load_hashes()

    def compute_hash(self, metadata: CLIMetadata) -> str:
        """Compute content hash for command metadata.

        The hash is computed from:
        - Command name and full path
        - All argument names and types
        - All option names, types, and help text
        - Help text and description

        Args:
            metadata: CLI metadata to hash

        Returns:
            SHA-256 hash string

        Example:
            >>> hasher = CLIHasher()
            >>> hash_value = hasher.compute_hash(metadata)
            >>> print(len(hash_value))
            64
        """
        # Build normalized string representation
        parts = [
            f"name:{metadata.name}",
            f"path:{metadata.full_path}",
            f"help:{metadata.help_text}",
            f"desc:{metadata.description}",
        ]

        # Add arguments
        for arg in metadata.arguments:
            parts.append(f"arg:{arg.name}:{arg.type}:{arg.required}")

        # Add options
        for opt in metadata.options:
            opt_names = ",".join(sorted(opt.names))
            parts.append(
                f"opt:{opt_names}:{opt.type}:{opt.required}:{opt.help_text}"
            )

        # Add subcommands
        for subcmd in metadata.subcommands:
            parts.append(f"subcmd:{subcmd.name}:{subcmd.help_text}")

        # Compute hash
        content = "\n".join(parts)
        return hashlib.sha256(content.encode("utf-8")).hexdigest()

    def has_changed(self, metadata: CLIMetadata) -> bool:
        """Check if command has changed since last hash.

        Args:
            metadata: CLI metadata to check

        Returns:
            True if command has changed or is new

        Example:
            >>> hasher = CLIHasher()
            >>> if hasher.has_changed(metadata):
            ...     print("Command changed, regenerate docs")
        """
        current_hash = self.compute_hash(metadata)
        previous_hash = self._hashes.get(metadata.name)

        if previous_hash is None:
            # New command
            return True

        return current_hash != previous_hash

    def update_hash(self, metadata: CLIMetadata) -> None:
        """Update stored hash for a command.

        Args:
            metadata: CLI metadata to store hash for

        Example:
            >>> hasher = CLIHasher()
            >>> hasher.update_hash(metadata)
            >>> hasher.save_hashes()
        """
        current_hash = self.compute_hash(metadata)
        self._hashes[metadata.name] = current_hash

    def save_hashes(self) -> bool:
        """Save all hashes to disk.

        Returns:
            True if save succeeded, False otherwise

        Example:
            >>> hasher = CLIHasher()
            >>> hasher.update_hash(metadata1)
            >>> hasher.update_hash(metadata2)
            >>> hasher.save_hashes()
            True
        """
        try:
            self.hash_file.parent.mkdir(parents=True, exist_ok=True)

            with open(self.hash_file, "w") as f:
                json.dump(self._hashes, f, indent=2, sort_keys=True)

            return True

        except Exception as e:
            print(f"Warning: Failed to save hashes to '{self.hash_file}': {e}", file=sys.stderr)
            return False

    def compare_hashes(
        self, current_commands: Dict[str, CLIMetadata]
    ) -> ChangeSet:
        """Compare current commands with stored hashes.

        Args:
            current_commands: Dictionary mapping command names to metadata

        Returns:
            ChangeSet describing what changed

        Example:
            >>> hasher = CLIHasher()
            >>> changeset = hasher.compare_hashes(commands)
            >>> print(f"Changed: {changeset.changed}")
            >>> print(f"Added: {changeset.added}")
            >>> print(f"Removed: {changeset.removed}")
        """
        changed = []
        added = []

        # Check for changes and additions
        for name, metadata in current_commands.items():
            if self.has_changed(metadata):
                if name in self._hashes:
                    changed.append(name)
                else:
                    added.append(name)

        # Check for removed commands
        current_names = set(current_commands.keys())
        stored_names = set(self._hashes.keys())
        removed = list(stored_names - current_names)

        return ChangeSet(changed=changed, added=added, removed=removed)

    def _load_hashes(self) -> None:
        """Load hashes from disk."""
        if not self.hash_file.exists():
            self._hashes = {}
            return

        try:
            with open(self.hash_file, "r") as f:
                self._hashes = json.load(f)
        except Exception as e:
            print(f"Warning: Failed to load hashes from '{self.hash_file}': {e}", file=sys.stderr)
            self._hashes = {}

    def clear_hashes(self) -> None:
        """Clear all stored hashes (force full regeneration)."""
        self._hashes = {}
        if self.hash_file.exists():
            self.hash_file.unlink()


__all__ = ["CLIHasher"]
